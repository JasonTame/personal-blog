---
title: 'Getting Started with PestPHP - Part 1'
author:
  - 5761106b-2220-429b-b49a-5e42cc8df619
updated_by: 5761106b-2220-429b-b49a-5e42cc8df619
updated_at: 1600862404
code: |
  # Intro
  
  Pest is a testing framework built on PHPUnit. According to the createor it was "carefully crafted to bring the joy of testing to PHP".
  
  It cuts out a lot of boilerplate that you'd generally need to write when testing with PHPUnit and instead lets you focus on the tests themselves. 
  
  Benefits:
  
  - 1 Great test reporting
  - 2 It's super easy to write and read Pest tests
  - 3 Much less boilerplate
  
  
  TODO: Discuss my own journey with testing and how I learned to test right as PestPHP was released
  
  ## Installation
  
  [Link to official install docs
  ](https://pestphp.com/docs/installation/)
  As mentioned, Pest is built on top of PHPUnit, so the first step is to make sure you have a phpunit.xml file at the project root. If you are using Laravel, it usually comes with one in a standard installation. Otherwise, here's [a link to one](https://github.com/pestphp/pest/blob/master/stubs/Laravel/phpunit.xml) on the pest repo
  
  Next, make sure your PHPUnit dependency is ^9.0
  
  ```
  composer require phpunit/phpunit:"^9.0" --dev --update-with-dependencies
  ```
  
  If you are using Laravel, require Collision ^5.0
  
  ```
  composer require nunomaduro/collision:"^5.0" --dev --update-with-dependencies
  ```
  
  **Note:** Collision 5.0 requires Laravel 8.0 or above. If you are on an older version, skip this step. You can still run PestPHP if you are on an older version of Laravel, but you will have to call it with `./vendor/bin/pest` rather than `php artisan test`.
  
  ## Converting PHPUnit tests to Pest tests
  
  Let's walk through the process of converting existing PHPUnit tests to Pest tests. Here's the test we'll change:
  
  ```php
  <?php
  
  namespace Tests\Unit;
  
  use Tests\TestCase;
  use Illuminate\Foundation\Testing\RefreshDatabase;
  
  class ArticlesTest extends TestCase
  <?php
  
  use App\Traits\WithAccessToken;
  use Laravel\Lumen\Testing\DatabaseMigrations;
  
  class SubscriptionsTest extends TestCase
  {
      use DatabaseMigrations;
      use WithAccessToken;
  
      /**
       * @test 
       */
      public function viewAllSubscriptions()
      {
          factory("App\Subscription")->create();
          $this->get('/api/subscriptions', $this->getHeader())->seeJsonStructure([
              '*' => [
                  'user_id',
                  'premium',
                  'type',
                  'cohort_ids',
                  'paid'
              ]
          ]);
      }
  
      /**
       * @test 
       */
      public function viewSingleSubscription()
      {
          $subscription_type = ['type' => 'Test Subscription'];
  
          $subscription = factory('App\Subscription')->create($subscription_type);
  
          $this->get('/api/subscriptions/' . $subscription->id, $this->getHeader())->seeJsonContains($subscription_type);
      }
  
      /**
       * @test 
       */
      public function addSubscription()
      {
          $subscription_data = [
              'user_id' => "user_11111",
              'premium' => false,
              'type' => 'Test Subscription',
              'cohort_ids' => '97,98,99',
              'paid' => true
          ];
  
          $this->post('/api/subscriptions', $subscription_data, $this->getHeader())->seeJsonContains($subscription_data);
      }
  
      /**
       * @test 
       */
      public function editSubscription()
      {
          $subscription_data = [
              'user_id' => "user_11111",
              'premium' => false,
              'type' => 'Test Subscription',
              'cohort_ids' => '97,98,99',
              'paid' => true
          ];
  
          $subscription = factory('App\Subscription')->create();
  
          $this->put('/api/subscriptions/' . $subscription->id, $subscription_data, $this->getHeader())->seeJsonContains($subscription_data);
      }
  
      /**
       * @test 
       */
      public function deleteSubscription()
      {
          $subscription = factory('App\Subscription')->create();
          $this->delete('/api/subscriptions/' . $subscription->id, [], $this->getHeader())->seeStatusCode(200);
  
      }
  }
  
id: 64fe190b-cd3c-438d-89ff-8eaa0983e74a
published: false
---
# Intro

Just over a year ago, my company decided we had reached the point where we needed to rewrite our web app from scratch. It had become bogged down in technical debt, an aging tech stack and poor infrastructure. 

We decided that one foundational practice we would put in place right from the start with the new app was testing. We had some tests previously, but more as an afterthought rather than a critical step in the build and release process.

For the first 6 months or so we built out our tests using PHPUnit with no issues. It's a solid testing framework! However, I was playing around with new technology one weekend I came across PestPHP and decided to start a new branch and give it a try. I loved it so much that the following week I rewrote all of our tests with it and pushed up a PR, and we haven't looked back since. 

## What is it?

![Pest Home Page](https://res.cloudinary.com/dkn9wtsgs/image/upload/v1600611327/blog/pest_home_page.png)

[Pest](https://pestphp.com/) is a testing framework which sits on top on PHPUnit. According to the creator it was "carefully crafted to bring the joy oftesting to PHP".

It cuts out a lot of boilerplate that you'd generally need to write when testing with PHPUnit and instead lets you focus on the tests themselves. 

## Benefits:

### Beautiful and informative test reporting

I love watching the Pest test runner go through my tests, it feels great watching all those green ticks fly by! 

![Pest Report](https://res.cloudinary.com/dkn9wtsgs/image/upload/v1600607112/blog/pest_reporting_screenshot.png)

When there is an error, it tries to be as clear as possible about what went wrong so you can get it resolved quickly

![Pest Error](https://res.cloudinary.com/dkn9wtsgs/image/upload/v1600607338/blog/pest_error_reporting.png)

### Easy to read and write

```php
<?php
test('users can be added to a cohort', function () {
    $cohort = factory(App\Cohort::class)->create();
    $user = factory(App\User::class)->create();

    json('POST', "/admin/cohorts/{$cohort->id}/users/{$user->id}")
        ->assertStatus(Response::HTTP_OK);

    assertDatabaseHas(
        'cohort_user',
        [
            'cohort_id' => $cohort->id,
            'user_id' => $user->id
        ]
    );
});

```

It's easy to see what the test is checking and the method calls use as little boilerplate as possible. If I was doing a series of tests which needed the `Cohort` and `User` models, I could have done something like this:

```php
<?php
beforeEach(function () {
    $this->cohort = factory(App\Cohort::class)->create();
    $this->user = factory(App\User::class)->create();
});


test('users can be added to a cohort', function () {
    json('POST', "/admin/cohorts/{$this->cohort->id}/users/{$this->user->id}")
        ->assertStatus(Response::HTTP_OK);

    assertDatabaseHas(
        'cohort_user',
        [
            'cohort_id' => $this->cohort->id,
            'user_id' => $this->user->id
        ]
    );
});
```

Pest provides ways of running code before and after each test or file using the `beforeEach()`, `beforeAll()`, `afterEach()` and `afterAll()` methods, allowing you to reduce boilerplate even further. 

Another huge improvement is that you don't have to concern yourself with classes or namespaces. You don't need to put all of your code into a class file which has the same name as the file it's in.  Just write your tests. 

You also don't have to worry about things like adding the word 'test' into the method name or adding a comment with the word 'test' above the function - just write your tests using the simple `it()` and `test()` methods and describe your tests using natural language.  

It might seem like it's not all that big a deal, but being able to get stuck right in with writing up tests makes a massive difference, especially when dealing with a large code base. 


## Installation

Let's look at how to go about installing PestPHP. 

[Link to official install docs
](https://pestphp.com/docs/installation/)


As mentioned, Pest is built on top of PHPUnit, so the first step is to make sure you have a phpunit.xml file at the project root. If you are using Laravel, it usually comes with one in a standard installation. Otherwise, here's [a link to one](https://github.com/pestphp/pest/blob/master/stubs/Laravel/phpunit.xml) on the pest repo

Next, make sure your PHPUnit dependency is ^9.0

```
composer require phpunit/phpunit:"^9.0" --dev --update-with-dependencies
```

If you are using Laravel, require Collision ^5.0

```
composer require nunomaduro/collision:"^5.0" --dev --update-with-dependencies
```

**Note:** Collision 5.0 requires Laravel 8.0 or above. If you are on an older version, skip this step. You can still run PestPHP if you are on an older version of Laravel, but you will have to call it with `./vendor/bin/pest` rather than `php artisan test`.

Next, require Pest:

```
composer require pestphp/pest --dev
```

It's now time to set up the test suite.

If you are using Laravel, you can go ahead and install the pest plugin for laravel and run the installation:

```
composer require pestphp/pest-plugin-laravel --dev && php artisan pest:install
```

If you are using another PHP project, you can initialise Pest with the following command:

```
./vendor/bin/pest --init
```

To run Pest from the command line, use the following command:

```
./vendor/bin/pest
```


## Converting PHPUnit tests to Pest tests

Let's walk through the process of converting existing PHPUnit tests to Pest tests. Here's an example:

```php
<?php

namespace Tests\Unit;

use Tests\TestCase;
use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Foundation\Testing\RefreshDatabase;

class ArticlesTest extends TestCase
{
    use RefreshDatabase;

    /**
     * @test
     */
    public function an_article_has_a_title_content_and_video()
    {
        factory('App\Article')
            ->create([
                'title' => 'Test article',
                'content' => 'Test content',
                'video_url' => 'some_video_url',
            ]);

        $this->assertDatabaseHas('articles', [
            'title' => 'Test article',
            'content' => 'Test content',
            'video_url' => 'some_video_url',
        ]);
    }

    /**
     * @test 
     */
    public function an_article_can_belong_to_a_collection()
    {
        $collection = factory('App\Collection')->create();
        $article = factory('App\Article')
            ->create([
                'collection_id' => $collection->id
            ]);

        $this->assertEquals($collection->id, $article->collection_id);
    }

    /**
     * @test 
     */
    public function an_article_can_be_tagged()
    {
        $article = factory('App\Article')->create();
        $tag = factory('App\Tag')->create();

        $article->addTag($tag);

        $this->assertCount(1, $article->tags);
        $this->assertTrue($article->tags->contains('id', $tag->id));
    }
}
```

Fairly basic set of tests. Here's the output if I run PHPUnit:

```
PHPUnit 8.5.4 by Sebastian Bergmann and contributors.

....E                                                               5 / 5 (100%)

Time: 250 ms, Memory: 28.00 MB

There was 1 error:

1) Tests\Unit\ArticlesTest::an_article_can_be_tagged
BadMethodCallException: Call to undefined method App\Article::addTag()

/Users/advantagelearn/Documents/Dev/advantagelearn_wiki/vendor/laravel/framework/src/Illuminate/Support/Traits/ForwardsCalls.php:50
/Users/advantagelearn/Documents/Dev/advantagelearn_wiki/vendor/laravel/framework/src/Illuminate/Support/Traits/ForwardsCalls.php:36
/Users/advantagelearn/Documents/Dev/advantagelearn_wiki/vendor/laravel/framework/src/Illuminate/Database/Eloquent/Model.php:1622
/Users/advantagelearn/Documents/Dev/advantagelearn_wiki/tests/Unit/ArticlesTest.php:77

ERRORS!
Tests: 5, Assertions: 4, Errors: 1.
```

Ok so we have 4 passing tests one one failure. We have a pretty good idea of what is wrong: It's trying to call `$article->addTag()` and that method doesn't exist for some reason. Let's leave it alone for now and convert to Pest so we can see the difference in error reporting.

```php
   FAIL  Tests\Unit\ArticlesTest
  ✓ an article has a title
  ✓ an article has content
  ✓ an article can have a video
  ✓ an article can belong to a collection
  ⨯ an article can be tagged

  ---

  • Tests\Unit\ArticlesTest > an article can be tagged
   BadMethodCallException 

  Call to undefined method App\Article::addTag()

  at vendor/laravel/framework/src/Illuminate/Support/Traits/ForwardsCalls.php:50
     46▕      * @throws \BadMethodCallException
     47▕      */
     48▕     protected static function throwBadMethodCallException($method)
     49▕     {
  ➜  50▕         throw new BadMethodCallException(sprintf(
     51▕             'Call to undefined method %s::%s()', static::class, $method
     52▕         ));
     53▕     }
     54▕ }

      +2 vendor frames 
  3   tests/Unit/ArticlesTest.php:77
      Illuminate\Database\Eloquent\Model::__call("addTag")


  Tests:  1 failed, 4 passed
  Time:   0.35s

```